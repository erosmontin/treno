import torch
import torch.nn as nn

class EMDiceLoss(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.eps=1e-7
    def forward(self, y_true, y_pred):
        y_true = y_true.float()
        y_pred = y_pred.float()
        return 1 - (2 * (y_true * y_pred).sum(dim=0) + self.eps) / (y_true.sum(dim=0) + y_pred.sum(dim=0) + self.eps)

class EMJaccardLoss(EMDiceLoss):
    
    def forward(self, target,output):
        output = torch.sigmoid(output)
        target = target.float()
        intersection = (output * target).sum(dim=1)
        union = output.sum(dim=1) + target.sum(dim=1) - intersection
        return 1 - (2 * intersection) / (union + self.eps)
class EMAccuracyLoss(EMDiceLoss):
    # Calculate the accuracy
    def forward(self, y_true, y_pred):
        correct = (y_pred == y_true).sum(dim=0)
        return correct.float() / y_true.size(0)
    
    
class EMSegmentaitonMultiLoss(nn.Module):
    def __init__(self, weight=None, size_average=True):
        super().__init__()
        self.weight = weight
        self.size_average = size_average
        self.ce=nn.functional.cross_entropy
        self.losses=[]
    def forward(self, y_true, y_pred):
        # Calculate the cross-entropy loss
        loss = self.ce(y_pred, y_true, weight=self.weight, size_average=self.size_average)

        for l in self.losses:
            loss+=l.forward(y_true,y_pred)
        return loss

class EMBinarySegmentaitonMultiLoss(nn.Module):
    def __init__(self) -> None:
        super().__init__()
        self.ce=nn.BCELoss()


